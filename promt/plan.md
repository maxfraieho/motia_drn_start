

# **Архітектурний План та Стратегія Розвитку: Модернізація DRAKON Viewer для Проєкту Motia**

## **Виконавче Резюме**

Цей документ представляє комплексний технічний аналіз та детальний план модернізації існуючого переглядача DRAKON-діаграм (DRAKON Viewer) у повнофункціональний, мобільно-адаптований редактор. Ключовою метою проєкту є глибока інтеграція оновленого інструменту в унікальний триступеневий підхід до розробки (Three-Level Approach), що використовується в проєкті Motia. Модернізація перетворить статичний засіб візуалізації на інтерактивне середовище для проєктування, документування та автоматизації, що стане центральним елементом робочого процесу розробників.

**Ключові висновки аналізу:**

1. **Поточний стан:** Існуючий DRAKON Viewer є мінімалістичною реалізацією на базі vanilla JavaScript, призначеною виключно для відображення діаграм. Його архітектура не передбачає розширення для функцій редагування чи мобільної адаптації. Відсутність складної застарілої кодової бази є перевагою, що дозволяє застосувати підхід "greenfield" до розробки нового рішення без обтяження технічним боргом.1  
2. **Основна технологія:** Бібліотека drakonwidget.js є потужним і зрілим інструментом, що підтримує не тільки перегляд, але й редагування діаграм. Це підтверджується її використанням як основи для більш просунутого комерційного продукту DrakonHub.2 Бібліотека надає низькорівневий API для рендерингу та маніпуляцій, що вимагає від хост-застосунку реалізації логіки стану та користувацького інтерфейсу для редагування.  
3. **Основний виклик та можливість:** Найбільш значущим технічним завданням є вимога автоматичної генерації DRAKON-діаграм з існуючого коду TypeScript/JavaScript. Це відкриває можливість для створення потужного інструменту рефакторингу та візуалізації, що значно підвищить продуктивність та розуміння кодової бази.

Стратегічні рекомендації:  
Пропонується розробка нового веб\-застосунку (Single Page Application, SPA) з використанням сучасного frontend-фреймворку (React або Vue) та архітектури, орієнтованої на компоненти. План передбачає реалізацію повного набору функцій редагування, створення діаграм з нуля та за шаблонами, а також розробку мобільного інтерфейсу за принципом "mobile-first" з підтримкою сенсорних жестів. Центральним нововведенням стане створення конвеєра "code-to-diagram" на основі аналізу Абстрактного синтаксичного дерева (AST) коду.  
Огляд дорожньої карти:  
План розвитку складається з п'яти послідовних фаз загальною тривалістю 12 тижнів. Процес починається зі створення архітектурного фундаменту та реалізації базового редактора, продовжується мобільною оптимізацією та розробкою розширених функцій, і завершується повною інтеграцією в робочий процес Motia та розгортанням у виробниче середовище.

## **Розділ 1: Фундаментальний Аналіз Екосистеми DRAKON**

Цей розділ присвячений деконструкції поточного стану проєкту та аналізу ключових технологій. Мета — встановити базовий рівень, визначити обмеження та виявити можливості для подальшого розвитку.

### **1.1 Оцінка Поточної Реалізації drakon-viewer**

Аналіз поточної реалізації базується на наданій структурі файлів (/home/vokov/motia-drn/tools/drakon-viewer/public/), оскільки вказаний URL (https://dangerboys.exodus.pp.ua/) є недоступним, що унеможливлює динамічний аналіз.1

Базовий аналіз архітектури:  
Поточна імплементація є класичним "vanilla" JavaScript-застосунком.

* **index.html**: Визначає базову структуру сторінки, включаючи контейнер для діаграми та підключення скриптів і стилів.  
* **app.js**: Містить логіку для завантаження JSON-файлів діаграм (ймовірно, через fetch API) та ініціалізації віджету drakonwidget.js для їх відображення в режимі "тільки для читання".  
* **style.css**: Забезпечує мінімальне стилістичне оформлення, необхідне для коректного відображення інтерфейсу.

**Передбачувана функціональність:**

* **Завантаження діаграм:** Діаграми завантажуються за жорстко визначеними шляхами, вказаними в app.js.  
* **Відображення:** Бібліотека drakonwidget.js використовується для рендерингу діаграми на HTML-елементі (ймовірно, canvas або div).  
* **Інтерактивність:** Обмежена виключно переглядом. Файлова структура не передбачає наявності коду для редагування, збереження чи створення нових діаграм.

Відсутність доступу до працюючого екземпляра переглядача та його простота є скоріше перевагою, ніж недоліком. Проєкт не обтяжений застарілою або складною кодовою базою, що вимагала б рефакторингу. Це дозволяє розпочати розробку нового редактора "з чистого аркуша", застосовуючи сучасні технології та архітектурні підходи без необхідності підтримувати зворотну сумісність. Такий підхід значно знижує ризики на початковому етапі проєкту та прискорює розробку.

Аналіз розриву (Gap Analysis):  
Для візуалізації масштабу проєкту нижче наведена таблиця, що порівнює поточний стан із необхідним функціоналом.  
**Таблиця 1: Аналіз розриву між поточним переглядачем та вимогами до редактора**

| Функція | Поточний стан (передбачуваний) | Необхідний стан | Пріоритет |
| :---- | :---- | :---- | :---- |
| Рендеринг діаграм (read-only) | ✅ Реалізовано | ✅ Зберегти | Високий |
| Редагування діаграм (CRUD) | ❌ Відсутнє | ✅ Повна реалізація | Високий |
| Створення нових діаграм | ❌ Відсутнє | ✅ З нуля та за шаблонами | Високий |
| Мобільна адаптація та жести | ❌ Відсутня | ✅ Повна підтримка | Високий |
| Генерація діаграм з коду | ❌ Відсутня | ✅ Автоматизований конвеєр | Критичний |
| Інтеграція з Motia Workflow | ❌ Відсутня | ✅ Інтеграція зі скриптами | Критичний |
| Експорт/Імпорт діаграм | ❌ Відсутнє | ✅ JSON, PNG/SVG | Середній |
| Функції колаборації | ❌ Відсутні | ✅ Коментарі, версіонування | Низький (майбутнє) |

### **1.2 Глибокий Аналіз drakonwidget.js: Оцінка Основного Рушія**

drakonwidget.js — це ключовий технологічний компонент, на якому буде побудовано новий редактор. Це автономна JavaScript-бібліотека без зовнішніх залежностей, призначена для перегляду та редагування DRAKON-діаграм.3

**API та конфігурація:**

* **Ініціалізація:** Віджет створюється викликом createDrakonWidget() та вбудовується в DOM за допомогою методу render(width, height, config).3  
* **Завантаження даних:** Діаграми завантажуються методом setDiagram(diagramId, diagram, sender), де diagram — це JSON-об'єкт діаграми, а sender — об'єкт для обробки подій редагування.3  
* **Об'єкт конфігурації:** Віджет гнучко налаштовується через config об'єкт, який дозволяє керувати візуальними параметрами (теми, шрифти, кольори через об'єкт theme), а також поведінкою (наприклад, allowResize, canSelect).3

Механізм редагування:  
Бібліотека drakonwidget реалізує модель редагування, керовану зворотними викликами (callbacks), що вимагає від хост-застосунку реалізації "мозку" системи.

1. **Відсутність вбудованого UI:** Сама бібліотека не містить готових UI-компонентів, таких як текстові редактори, модальні вікна чи контекстні меню. Вона надає лише полотно для рендерингу та низькорівневі обробники подій.  
2. **Обов'язкові callbacks:** Для активації режиму редагування хост-застосунок *зобов'язаний* надати власні реалізації функцій, таких як startEditContent (для редагування тексту вузла) та showContextMenu (для відображення контекстного меню).3 Коли користувач, наприклад, двічі клацає на вузлі, віджет викликає надану функцію startEditContent.  
3. **Обробка змін:** Для отримання повідомлень про зміни (переміщення вузла, зміна зв'язку) необхідно передати об'єкт EditSender з методом pushEdit(edit). Цей метод отримує об'єкт, що описує зміну (наприклад, {op: "update", fields: {...}}).3  
4. **Архітектурний висновок:** drakonwidget надає "м'язи" (рендеринг, виявлення перетягування), але не "мозок" (управління станом, UI-компоненти). Це фундаментальне архітектурне спостереження диктує необхідність використання сучасного frontend-фреймворку. Новий редактор повинен інкапсулювати віджет у компонент, що керує станом (stateful component), який буде відповідати за управління даними діаграми, надання необхідних UI-елементів та реалізацію всіх обов'язкових callbacks.

**Таблиця 2: Оцінка API та функціональності drakonwidget**

| Область функціональності | API / Конфігурація | Підтримка | Примітки та обмеження |
| :---- | :---- | :---- | :---- |
| Рендеринг | render(), redraw() | ✅ Так | Повна підтримка. |
| Завантаження даних | setDiagram() | ✅ Так | Для редагування вимагає об'єкт EditSender. |
| Редагування контенту | editContent(), startEditContent | ✅ Через callback | Вимагає реалізації власного UI для редагування. |
| Контекстні меню | showContextMenu | ✅ Через callback | Вимагає реалізації власного UI для меню. |
| Виділення/Буфер обміну | copySelection(), cutSelection(), deleteSelection() | ✅ Так | Надає базові операції. |
| Експорт | exportJson(), exportCanvas() | ✅ Так | Експорт у canvas вимагає config.canvasIcons: true. |
| Масштабування/Панорамування | onZoomChanged | 🟡 Частково | Віджет керує масштабуванням; панорамування може вимагати додаткової реалізації. |

### **1.3 Аналіз Структури Даних JSON для DRAKON-діаграм**

Аналіз структури даних базується на наданих шляхах до файлів (bot-core-flow.json та ін.) та документації бібліотеки.

**Ключові елементи структури:**

* **Кореневий об'єкт:** Містить метадані, такі як name (назва діаграми), access (рівень доступу) та масив params (параметри).  
* **Об'єкт items:** Ядро діаграми. Це словник (об'єкт), де ключами є унікальні ідентифікатори вузлів.  
* **Властивості вузла (item):** Кожен об'єкт вузла містить:  
  * type: Критично важливе поле, що визначає тип іконки ("action", "question", "branch", "end" тощо).3  
  * content: Текстовий вміст, що відображається всередині вузла.  
  * branchId: Ціле число, що ідентифікує вертикальну лінію ("силует"), до якої належить вузол.  
  * **Керування потоком:** Властивості, такі як one (для послідовних дій), yes та no (для умов), містять ID наступного вузла, визначаючи логіку діаграми.

Пропозиція щодо JSON Schema:  
Для забезпечення цілісності даних та спрощення валідації буде розроблено формальну JSON Schema. Ця схема буде використовуватися для перевірки діаграм під час створення, збереження та автоматичної генерації. Вона буде визначати обов'язкові поля, типи даних та допустимі значення для поля type. Застосування JSON Schema є найкращою практикою, що запобігає пошкодженню даних, спрощує налагодження та слугує формальною документацією формату.4

### **1.4 Методологія DRAKON: Керівні Принципи для UX та Логіки**

Дизайн редактора та його автоматизованих інструментів не може ігнорувати строгі правила методології DRAKON, які спрямовані на зменшення когнітивного навантаження та покращення читабельності.6

* **Ключові принципи:**  
  * **Відсутність перетинів ліній:** Алгоритм компонування повинен суворо дотримуватися цього правила. drakonwidget автоматично забезпечує його виконання.  
  * **"Шампур" (Skewer):** Основна вертикальна лінія, що представляє "щасливий шлях" (happy path) або основний потік логіки.6 Інтерфейс редактора повинен дозволяти легко додавати вузли на "шампур".  
  * **"Силует" (Silhouette):** Структура розгалужень, що розбиває діаграму на логічні частини. Інтерфейс повинен надавати чіткі механізми для створення та управління цими гілками.6  
  * **Напрямок читання:** Зверху вниз, з розгалуженнями праворуч. "Гірші" або менш ймовірні шляхи повинні розташовуватися правіше.8

Ці принципи є не просто візуальними рекомендаціями, а фундаментальними правилами, що мають керувати логікою автоматичної генерації діаграм. Наприклад, при аналізі коду, що містить конструкцію try...catch, наївний генератор міг би розмістити блоки try і catch на рівнозначних гілках. Однак це порушує принцип DRAKON про пріоритет "щасливого шляху". Блок try представляє очікуваний, успішний шлях виконання, тоді як блок catch — винятковий, менш бажаний сценарій.

Тому семантичний шар-транслятор (Semantic Mapper), відповідальний за перетворення коду на діаграму, повинен містити евристики, засновані на цих принципах. Він має бути запрограмований так, щоб розпізнавати блок try як основний потік і розміщувати його на "шампурі". Блок catch повинен автоматично розміщуватися на новій гілці праворуч. Аналогічно, для умовного оператора, що перевіряє помилку (наприклад, if (error)), логіка всередині if повинна бути винесена на праву гілку, тоді як подальший код продовжується по основному "шампуру". Таке впровадження методологічних правил в алгоритм генерації зробить діаграми, що створюються автоматично, по-справжньому корисними та читабельними, а не просто буквальним, хаотичним перекладом синтаксису коду.

## **Розділ 2: Стратегічний Архітектурний План для Розширеного Редактора DRAKON**

Цей розділ переходить від аналізу до розробки конкретного архітектурного проєкту для нового застосунку.

### **2.1 Пропонована Frontend-архітектура**

Рекомендації щодо технологічного стеку:  
Для створення сучасного, масштабованого та підтримуваного SPA-застосунку рекомендується наступний набір технологій.  
**Таблиця 3: Рекомендований технологічний стек та його обґрунтування**

| Компонент | Рекомендована технологія | Обґрунтування |
| :---- | :---- | :---- |
| UI Framework | **React** / **Vue** | Компонентна модель ідеально підходить для складного UI; великі екосистеми та потужна підтримка спільноти. Вибір залежить від експертизи команди. |
| Інструмент збірки | **Vite** | Значно вища швидкість роботи сервера для розробки та Hot Module Replacement (HMR) порівняно з Webpack. |
| Управління станом | **Redux Toolkit** / **Pinia** | Централізоване сховище стану є критично важливим для таких функцій, як undo/redo та автозбереження. Мінімізує шаблонний код. |
| Бібліотека для жестів | **panzoom** / **react-zoom-pan-pinch** | Надає готові, оптимізовані рішення для панорамування та масштабування дотиком, що значно економить час розробки.10 |

Компонентна архітектура:  
Застосунок буде структуровано навколо наступних ключових компонентів:

* **DrakonEditorContainer**: Основний stateful-компонент, що ініціалізує drakonwidget, керує станом діаграми (JSON-об'єкт, історія змін), та реалізує необхідні callbacks (startEditContent тощо).  
* **Toolbar**: Stateless-компонент, що отримує функції-обробники від контейнера для виконання дій (збереження, експорт, додавання вузлів, масштабування).  
* **PropertiesPanel**: Компонент для відображення та редагування властивостей виділеного вузла (текст, тип, колір).  
* **CanvasWrapper**: Компонент, що безпосередньо містить DOM-елемент для рендерингу drakonwidget. Він обробляє зміну розмірів та передає події до головного контейнера.  
* **EditModal**: Універсальний модальний компонент, що викликається через startEditContent для надання зручного інтерфейсу редагування тексту вузлів.

### **2.2 Мобільно-орієнтований Адаптивний Дизайн та Модель Взаємодії**

Стратегія компонування:  
Інтерфейс буде розроблено за принципом "mobile-first". На малих екранах Toolbar та PropertiesPanel будуть згортатися або відображатися у вигляді нижніх панелей (bottom sheet/drawer), щоб максимізувати видиму область полотна.  
**Підтримка сенсорних жестів:**

* **Масштабування та панорамування:** Буде інтегровано спеціалізовану бібліотеку, таку як @timmywil/panzoom 12 або react-zoom-pan-pinch 11, для навігації по полотну. Ці бібліотеки оптимізовані для мобільних пристроїв.  
* **Взаємодія з вузлами:** Стандартний механізм drag-and-drop є неефективним та незручним на сенсорних екранах. Палець є неточним інструментом і закриває елемент, що перетягується, що робить точне з'єднання вузлів майже неможливим. Тому пропонується альтернативна модель взаємодії:  
  * Один дотик (tap) до вузла виділяє його.  
  * Повторний дотик до виділеного вузла активує "режим з'єднання". Після цього дотик до цільового вузла створює між ними зв'язок.  
  * Для переміщення вузла буде використовуватися тривале натискання (long-press), що супроводжується вібровідгуком. Це запобігає випадковим перетягуванням і робить процес більш контрольованим.

**ASCII-макети інтерфейсу:**

* **Смартфон (портретний режим):**  
  \+---------------------------------+

| \[≡\] Toolbar (collapsed) \[💾\] |  
\+---------------------------------+  
| |  
| |  
| \< Canvas Area \> |  
| |  
| |  
| |  
\+---------------------------------+  
| \[Action\]\[Quest\]\[+\]\[⚙️\] (Panel)|  
\+---------------------------------+  
\`\`\`

* **Планшет (ландшафтний режим):**  
  \+------------------------------------------------------+

| \[File\]\[Edit\]\[Zoom In\]\[Zoom Out\]\[💾\]\[▶️\] |  
\+------------------------------------------------------+  
| \[A\] | |  
| \[Q\] | |  
| \[+\] | Canvas Area |  
| \[L\] | |  
| (V-Toolbar) |  
\+------------------------------------------------------+  
\`\`\`

### **2.3 Реалізація Повнофункціонального Редагування**

* **Рендеринг, керований станом:** DrakonEditorContainer буде зберігати повний JSON-об'єкт діаграми у своєму стані. Будь-яка дія користувача (редагування тексту, переміщення вузла) спочатку оновлює цей стан. useEffect hook буде відстежувати зміни стану та викликати drakon.setDiagram() для перерендерингу віджета з новими даними. Це забезпечує односпрямований потік даних, що робить поведінку застосунку передбачуваною та легкою для налагодження.  
* **Undo/Redo:** Рішення для управління станом буде налаштовано для зберігання історії станів. Кнопки "Скасувати" та "Повторити" на панелі інструментів будуть просто відправляти дії для переміщення вперед або назад по цій історії.  
* **Додавання нових вузлів:** Toolbar міститиме кнопки для кожного типу вузла. Натискання на кнопку буде додавати новий об'єкт вузла до JSON-об'єкта діаграми у стані, розміщуючи його за замовчуванням відносно поточного виділеного елемента, що автоматично викличе перерендеринг.

### **2.4 Стратегія Інтеграції з Backend та Колаборації**

* **Початкова фаза (локальна):** На першому етапі редактор буде працювати в локальному режимі, завантажуючи та зберігаючи діаграми у файлову систему через браузерні API. Це повністю задовольняє базову вимогу редагування JSON-файлів у каталозі motia-output/steps/.  
* **Підготовка до майбутньої колаборації:** Архітектура повинна передбачати можливість інтеграції з backend. Пропонується спланувати простий API на базі Node.js та Express:  
  * **Ендпоінти:**  
    * GET /api/diagrams/:id: Отримати JSON діаграми.  
    * PUT /api/diagrams/:id: Зберегти/оновити JSON діаграми.  
  * **Реальний час:** Для майбутньої багатокористувацької колаборації цей API може бути розширений за допомогою WebSockets. Коли один користувач надсилає зміну (подія pushEdit), сервер може транслювати її всім іншим підключеним клієнтам, які оновлять свій локальний стан.

## **Розділ 3: Інтеграція з Триступеневим Робочим Процесом Motia**

Цей розділ деталізує, як редактор стане невід'ємною частиною екосистеми Motia.

### **3.1 Автоматизація Генерації Діаграм: Конвеєр Code-to-DRAKON**

**Основна технологія:** **TypeScript Compiler API**. Цей інструмент надає програмний доступ до компілятора TypeScript, дозволяючи парсити вихідні файли в Абстрактне синтаксичне дерево (AST) без виконання повної компіляції.13

Семантичний шар-транслятор (Semantic Mapping Layer):  
Це ключовий компонент, який необхідно розробити. Він буде представляти собою бібліотеку функцій, що перетворюють вузли AST на структури JSON для DRAKON-діаграм.

* mapIfStatement(node) \-\> Створює іконку "question" з гілками "yes" та "no".  
* mapForLoop(node) \-\> Створює структуру іконок "loop".  
* mapTryStatement(node) \-\> Створює основний шлях для блоку try та праву гілку для блоку catch, реалізуючи принцип "щасливого шляху" DRAKON.  
* mapFunctionCall(node) \-\> Створює іконку "action".

**План реалізації:**

1. Створити окремий Node.js скрипт (наприклад, generate-drakon.ts).  
2. Скрипт буде приймати шлях до файлу та назву функції/класу як вхідні параметри.  
3. Він буде використовувати ts.createProgram для завантаження файлу та його залежностей.  
4. Скрипт буде обходити AST для знаходження цільової функції/класу. Для спрощення обходу можна використовувати бібліотеки, такі як astq 17 або утиліти з пакету abstract-syntax-tree.18  
5. Далі він рекурсивно обробить тіло функції, використовуючи Semantic Mapping Layer для побудови JSON-об'єкта DRAKON у пам'яті.  
6. Нарешті, він запише отриманий JSON у вказаний вихідний файл.

### **3.2 Безшовна Інтеграція в Робочий Процес**

Інтеграція з unified-motia-workflow.sh:  
Скрипт generate-drakon.ts буде інтегровано в основний shell-скрипт робочого процесу. Після кроку, що модифікує вихідний код, скрипт автоматично викликатиме генератор:

Bash

\# Усередині unified-motia-workflow.sh  
\#... після кроку генерації або модифікації коду...  
echo "Generating DRAKON diagram for new logic..."  
node./tools/drakon-editor/generate-drakon.js \\  
  \--file./src/new-feature.ts \\  
  \--func handleNewFeature \\  
  \--output./motia-output/steps/new-feature-flow.json

Взаємодія з Claude AI:  
Згенеровані JSON-діаграми, будучи структурованим поданням логіки, можуть бути серіалізовані в компактний текстовий формат і включені в промпти, що надсилаються до Claude (визначені в CLAUDE-CORE.md). Це надасть AI чітке та однозначне уявлення про потік керування програмою, що потенційно призведе до кращого аналізу та генерації коду.

### **3.3 Конфігурація Docker-середовища для Розробки та Продакшену**

Оновлення docker-compose.yml:  
Буде додано новий сервіс для редактора DRAKON.

YAML

services:  
  \#... існуючі сервіси...  
  drakon-editor:  
    build:  
      context:./tools/drakon-editor  
      dockerfile: Dockerfile.dev  
    ports:  
      \- "8080:8080"  
    volumes:  
      \-./tools/drakon-editor:/app  
      \-./motia-output:/app/public/diagrams \# Монтування діаграм для легкого доступу  
    command: npm run dev \# Використання dev-сервера Vite

Середовище розробки:  
Конфігурація Docker забезпечить підтримку "гарячого перезавантаження" (hot-reloading). Коли розробник зберігає зміни у вихідному коді редактора, dev-сервер Vite автоматично оновлює застосунок у браузері без повного перезапуску контейнера.  
Продакшн-збірка:  
Буде створено багатоступеневий Dockerfile. Перший етап встановлює залежності та збирає статичні frontend-ресурси (HTML, JS, CSS). Фінальний, полегшений етап буде використовувати простий веб\-сервер, такий як Nginx, для роздачі цих статичних файлів.

## **Розділ 4: Пофазовий План Реалізації та Оцінка Ризиків**

Цей розділ містить дієвий план проєкту.

### **4.1 Детальна Дорожня Карта Розробки**

Нижче наведено розширену версію запропонованої дорожньої карти з більш гранульованими завданнями.

**Таблиця 4: Детальна дорожня карта проєкту з етапами та термінами**

| Фаза | Тривалість | Ключові завдання | Результати / Віхи |
| :---- | :---- | :---- | :---- |
| **1: Фундамент** | Тижні 1-2 | Налаштування проєкту Vite+React/Vue, конфігурація Docker з hot-reloading, створення базових компонентів, інтеграція drakonwidget для read-only. | Працююче dev-середовище, що здатне відображати існуючі діаграми. |
| **2: Ядро редактора** | Тижні 3-5 | Реалізація state management, DrakonEditorContainer, Toolbar, PropertiesPanel, startEditContent з модальним вікном, додавання/видалення вузлів, undo/redo. | Функціональний десктопний редактор діаграм. |
| **3: Мобільна оптимізація** | Тижні 6-7 | Реалізація адаптивних макетів, інтеграція бібліотеки pan/zoom, реалізація логіки взаємодії для сенсорних екранів (long-press, tap-tap). | Редактор повністю придатний для використання на мобільних пристроях. |
| **4: Розширені функції** | Тижні 8-10 | Створення майстра створення діаграм з шаблонами, експорт у JSON/PNG, розробка генератора code-to-diagram (парсер AST та Semantic Mapper). | Автономний скрипт code-to-diagram працює для ключових конструкцій. |
| **5: Інтеграція та розгортання** | Тижні 11-12 | Інтеграція генератора в unified-motia-workflow.sh, налаштування продакшн-збірки Docker, налаштування CI/CD, фінальне тестування, документація. | Повністю інтегрований редактор DRAKON розгорнуто та введено в експлуатацію. |

### **4.2 Стратегія Забезпечення Якості та Тестування**

* **Модульне тестування (Unit Testing):** Використання Vitest/Jest для тестування окремих компонентів та утиліт, особливо складної логіки в Semantic Mapper.  
* **Інтеграційне тестування:** Тестування взаємодії між компонентами, наприклад, перевірка, що натискання кнопки "Додати вузол" у Toolbar коректно оновлює стан у DrakonEditorContainer та викликає перерендеринг.  
* **Наскрізне тестування (E2E Testing):** Використання фреймворків, таких як Cypress або Playwright, для автоматизації сценаріїв користувача: відкриття діаграми, додавання вузла, редагування тексту, збереження та перевірка вихідного JSON.

### **4.3 Виявлені Ризики та Стратегії їх Пом'якшення**

* **Ризик 1 (Висока складність): Генератор "Code-to-Diagram"**  
  * *Опис:* Алгоритм є складним і може не впоратися з усіма граничними випадками синтаксису коду.  
  * *Пом'якшення:* Почати з обмеженого набору функцій, підтримуючи лише найпоширеніші структури керування (if/else, for, try/catch). Чітко задокументувати обмеження. Згенерована діаграма повинна розглядатися як початкова точка, яку можна доопрацювати вручну в редакторі.  
* **Ризик 2 (Середній виклик для UX): Інтуїтивність на мобільних пристроях**  
  * *Опис:* Досягнення справді зручного редагування на малих сенсорних екранах є складним завданням.  
  * *Пом'якшення:* Виділити окремий час на тестування користувачами та ітерації над мобільним UX. Бути готовими до прототипування альтернативних моделей взаємодії (наприклад, режим фокусування, меню на основі жестів).  
* **Ризик 3 (Низький технічний ризик): Залежність від drakonwidget**  
  * *Опис:* Бібліотека є зовнішньою залежністю і може містити приховані помилки або обмеження.  
  * *Пом'якшення:* Ризик знижується тим, що бібліотека має відкритий код і використовується в комерційному продукті. Провести "spike" (коротке дослідження) на Фазі 1 для тестування її меж зі складними діаграмами перед повною інтеграцією. Відсутність залежностей у самої бібліотеки усуває ризик конфліктів.

## **Висновок**

Пропонований план модернізації DRAKON Viewer є стратегічною інвестицією в інфраструктуру проєкту Motia. Перехід від простого переглядача до повноцінного інтерактивного редактора, глибоко інтегрованого в робочий процес, дозволить досягти кількох ключових цілей: підвищити швидкість розробки, покращити якість коду за рахунок кращої візуалізації логіки, спростити онбординг нових членів команди та посилити можливості взаємодії з AI-системами.

Запропонована архітектура на базі сучасного frontend-стеку забезпечить масштабованість, підтримуваність та чудовий користувацький досвід як на десктопних, так і на мобільних пристроях. Найбільш інноваційною частиною проєкту є створення конвеєра "code-to-diagram", який автоматизує процес документування та аналізу коду, перетворюючи діаграми з артефакту, що створюється вручну, на динамічне відображення реального стану системи. Успішна реалізація цього плану перетворить DRAKON-діаграми на центральний, живий інструмент у триступеневому підході до розробки в проєкті Motia.

#### **Джерела**

1. dangerboys.exodus.pp.ua, доступ отримано жовтня 17, 2025, [https://dangerboys.exodus.pp.ua/](https://dangerboys.exodus.pp.ua/)  
2. stepan-mitkin/drakonhub: The source code for DrakonHub \- GitHub, доступ отримано жовтня 17, 2025, [https://github.com/stepan-mitkin/drakonhub](https://github.com/stepan-mitkin/drakonhub)  
3. stepan-mitkin/drakonwidget: A JavaScript widget for viewing and editing drakon flowcharts \- GitHub, доступ отримано жовтня 17, 2025, [https://github.com/stepan-mitkin/drakonwidget](https://github.com/stepan-mitkin/drakonwidget)  
4. Creating your first schema \- JSON Schema, доступ отримано жовтня 17, 2025, [https://json-schema.org/learn/getting-started-step-by-step](https://json-schema.org/learn/getting-started-step-by-step)  
5. Miscellaneous Examples \- JSON Schema, доступ отримано жовтня 17, 2025, [https://json-schema.org/learn/miscellaneous-examples](https://json-schema.org/learn/miscellaneous-examples)  
6. Our Accelerators | Drakon Mapping \- VMG Labs, доступ отримано жовтня 17, 2025, [https://vmglabs.com/drakon-mapping](https://vmglabs.com/drakon-mapping)  
7. DrakonTech, доступ отримано жовтня 17, 2025, [https://drakon.tech/](https://drakon.tech/)  
8. The DRAKON Language \- DrakonFlow, доступ отримано жовтня 17, 2025, [https://drakonflow.com/read/drakon](https://drakonflow.com/read/drakon)  
9. DRAKON.pdf, доступ отримано жовтня 17, 2025, [https://drakon-editor.sourceforge.net/DRAKON.pdf](https://drakon-editor.sourceforge.net/DRAKON.pdf)  
10. Pan / zoom for any element \- GitHub, доступ отримано жовтня 17, 2025, [https://github.com/dy/pan-zoom](https://github.com/dy/pan-zoom)  
11. react-zoom-pan-pinch \- NPM, доступ отримано жовтня 17, 2025, [https://www.npmjs.com/package/react-zoom-pan-pinch](https://www.npmjs.com/package/react-zoom-pan-pinch)  
12. timmywil/panzoom: A library for panning and zooming elements using CSS transforms :mag \- GitHub, доступ отримано жовтня 17, 2025, [https://github.com/timmywil/panzoom](https://github.com/timmywil/panzoom)  
13. TypeScript Compiler API Book, доступ отримано жовтня 17, 2025, [https://typescriptcompilerapi.com/](https://typescriptcompilerapi.com/)  
14. Abstract Syntax Tree In TypeScript \- DEV Community, доступ отримано жовтня 17, 2025, [https://dev.to/bilelsalemdev/abstract-syntax-tree-in-typescript-25ap](https://dev.to/bilelsalemdev/abstract-syntax-tree-in-typescript-25ap)  
15. Gentle Introduction To Typescript Compiler API \- DEV Community, доступ отримано жовтня 17, 2025, [https://dev.to/this-is-learning/gentle-introduction-to-typescript-compiler-api-3n4n](https://dev.to/this-is-learning/gentle-introduction-to-typescript-compiler-api-3n4n)  
16. Compiler API (TypeScript) | learning-notes \- mistermicheels, доступ отримано жовтня 17, 2025, [https://learning-notes.mistermicheels.com/javascript/typescript/compiler-api/](https://learning-notes.mistermicheels.com/javascript/typescript/compiler-api/)  
17. rse/astq: Abstract Syntax Tree (AST) Query Engine \- GitHub, доступ отримано жовтня 17, 2025, [https://github.com/rse/astq](https://github.com/rse/astq)  
18. abstract-syntax-tree \- NPM, доступ отримано жовтня 17, 2025, [https://www.npmjs.com/package/abstract-syntax-tree](https://www.npmjs.com/package/abstract-syntax-tree)